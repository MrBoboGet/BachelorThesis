\documentclass{amsart}
%\usepackage{amsmath} 
%\usepackage{amssymb}
%\usepackage{graphicx}
%\usepackage{pictex}
%\usepackage[noend]{algorithmic}
%\usepackage{algorithm}
%\renewcommand{\algorithmiccomment}[1]{\hfill$\rhd???$\textit{#1}}
%\usepackage{mathtools}
%\providecommand{\keywords}[1]{\textbf{\textit{Keywords: }} #1}
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}


% COPY PASTE

\usepackage{authblk}
%\usepackage[numbers,sort&compress]{natbib}
%\usepackage[numbers, sort&compress]{natbib}



\usepackage[colorlinks]{hyperref}
\hypersetup{
	citecolor=blue,
   linkcolor=red,
}

\usepackage{amsmath, amssymb, amsfonts, amsfonts, amsthm,latexsym}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}
\renewcommand{\algorithmiccomment}[1]{\hfill$\rhd???$\textit{#1}}
\usepackage{graphics}
\usepackage{enumerate}
\usepackage[usenames]{color}
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}%[section]
\newtheorem{lemma}[theorem]{Lemma}%[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}[theorem]{Corollary}%[section]
\newtheorem{remark}[theorem]{Remark}%[section]
\newtheorem{problem}{Problem}[section]
\newtheorem{observ}{Observation}
\usepackage{url}
\RequirePackage{hyperref}
\DeclareMathOperator{\sgn}{sgn}

\DeclareSymbolFont{yhlargesymbols}{OMX}{yhex}{m}{n}
\DeclareMathAccent{\overarc}{\mathord}{yhlargesymbols}{"F3}

%%%%% SOME LOW LEVEL STUFF NEEDED FOR SPECIAL SYMBOLS 
\makeatletter
\def\moverlay{\mathpalette\mov@rlay}
\def\mov@rlay#1#2{\leavevmode\vtop{%
    \baselineskip\z@skip \lineskiplimit-\maxdimen
    \ialign{\hfil$\m@th#1##$\hfil\cr#2\crcr}}}
\newcommand{\charfusion}[3][\mathord]{
  #1{\ifx#1\mathop\vphantom{#2}\fi
    \mathpalette\mov@rlay{#2\cr#3}
  }
  \ifx#1\mathop\expandafter\displaylimits\fi}
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{\ifx#1\displaystyle.9\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}%
  }%
}
\makeatother
%%%%% END LOWLEVEL USER DEFINITION 
\newcommand{\bigjoin}{\bigop{\triangledown}}
\DeclareMathOperator{\join}{\triangledown}
\newcommand{\cupdot}{\charfusion[\mathbin]{\cup}{\cdot}}
\DeclareMathOperator{\bigcupdot}{\charfusion[\mathop]{\bigcup}{\cdot}}
\definecolor{jade}{rgb}{0.0, 0.66, 0.42}
\newcommand{\child}{\mathsf{child}}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\Pmax}{\mathrm{Pmax}}
\newcommand{\T}{\widetilde{T}}
\renewcommand{\t}{\widetilde{t}}

%\definecolor{darkorchid}{rgb}{0.6, 0.2, 0.8}

%\newcommand{\TODO}[1]{\begingroup\color{red}#1\endgroup}
\newcommand{\AX}[1]{\textnormal{#1}}
%%\newcommand{\NEW}[1]{\begingroup\color{blue}#1\endgroup}
%\newcommand{\dv}[1]{\begingroup\color{jade}#1\endgroup}
%\newcommand{\OLD}[1]{\begingroup\small	\color{green}#1\endgroup}
%\newcommand{\PFS}[1]{\begingroup\color{blue}#1\endgroup}
%\newcommand{\mhr}[1]{\begingroup\color{darkorchid}#1\endgroup}
%\newcommand{\mh}[1]{\begingroup\color{magenta}#1\endgroup}
%\newcommand{\mg}[1]{\begingroup\color{cyan}#1\endgroup}

%%\journal{European Journal of Combinatorics} 

\providecommand{\keywords}[1]{\textbf{\textit{Keywords: }} #1}

 % END COPY PASTE


\usepackage[backend=bibtex]{biblatex}
\usepackage{todonotes}
\addbibresource{References.bib}


\newcommand{\algorithmicbreak}{\textbf{break}}
\newcommand{\BREAK}{\STATE \algorithmicbreak}
\newcommand{\algorithmautorefname}{Algorithm}
\author{Emanuel Berggren}
\title{Graph coloring using modular decomposition}

\begin{document}
\maketitle

\section{Abstract}

Lorem ipsum

\section{Introduction}

In this paper, we investigate a new heuristic using the modular decomposition of
a graph, and if it can be combined with other heuristics. 

The modular decomposition of a graph describes the structure of the graph, by
recursively splitting it into distinct modules. These modules contain some
vertexes from the graph, and can be further split into modules that partition
the top module. Every parent vertex also has a type, that determine how its submodules
combine to form their parent module.

Modular decomposition allows for coloring of graphs in linear time with optimal
chromatic number if all of the modules are either  series or
parallel \cite{HCL}. However, if any of the vertexes are prime then optimal graph coloring 
is again NP-Hard, as prime vertexes cannot be recursively colored by this
method. The question examined here, is if one can still utilize the
modular decomposition, with graph coloring heuristics for the prime modules.
The modular decomposition might still color some parts of the graph optimally,
and the structure it provides might provide a hint for how to apply the
heuristics on the prime parts, improving performance for other heuristics.

%kanske rätt onödigt?
In \autoref{sec:Definitions} all of the required terminology and definitions is
provided, and is split into two parts, \autoref{sec:GraphBasics} has definitions that might be
familiar to most people that have worked with graphs, and
\autoref{sec:GraphModules} provide the definitions that are more specific to
this paper.

In \autoref{sec:Heuristics} the graph coloring heuristics used are described.

In \autoref{sec:Strategies} the combination strategies are described, that is how are
these heuristics applied, and how is the structure of the modular decomposition
utilised.

In \autoref{sec:Data} the test graphs and benchmarking methods are described. The data
used is both from standard DIMACS benchmarks \cite{DIMACS}, and custom generated data.

Finally, the results are presented in \autoref{sec:Result}.

\section{Definitions}
\label{sec:Definitions}

\subsection{Graph basics}
\label{sec:GraphBasics}

\begin{definition}[Graph]
    A graph $G = (V,E)$ is a tuple, where $V$ is the set of vertices, and $E$ is
    a set of pairs of vertices, the edges, such that for all $(v,u) \in E$,
    $v \in V$ and $u \in V$.
\end{definition}
\begin{definition}[Neighbour]
    For a graph $G = (V,E)$, we say that $v \in V$ is adjacent to 
    $u \in V$ if $(v,u) \in E$ or $(u,v) \in E$. 

    The neighbourhood $N_G(v)$ for a vertex $v \in V$ in a graph $G = (V,E)$,
    is the set of vertices that are adjacent to $v$, that is 
    $N_G(v) = \{u : (u,v) \in E \vee (v,u) \in E\}$. If $u \in N_G(v)$, we also say
    that $u$ and $v$ are neighbours.
\end{definition}
\begin{definition}[Degree]
    The degree for a vertex $v \in V$ in a graph $G = (V,E)$, denoted by 
    $deg(v)$, is the number of neighbours for $v$ in $G$, that is 
    $deg(v) = |N_G(v)|$.
\end{definition}

In many cases, one is interested in some parts of the graph, and one of the
most common ways to subset a graph is through the induced subgraph. The induced
subgraph is the graph constructed from another graph, by only including a subset
of it's vertices, and edges between them.

\begin{definition}[Induced subgraph]
    
    For a graph $G = (V,E)$, the induced subgraph $G[X]$ for $X \subset V$, is
    an a new graph $(X,\{(u,v) : (u,v) \in E, u \in X,v \in X\})$. That
    is, a new graph only containing the vertices in $X$, and only edges between
    these vertices.

\end{definition}

Another common operation, is the graph complement. The graph complement of a
graph is graph that contains the same vertices as the original graph, but the
vertices are adjacent only of they where not adjacent in the original graph.
This also means that the union of their edge sets contains all possible edges
between the vertices.

\begin{definition}[Graph complement]
    The graph compliment $\overline{G}$ of a graph $G = (V,E)$ as a new graph 
    $(V,\{ (u,v) : u \in V,v \in V, (u,v) \notin E,(v,u) \notin E\})$.
\end{definition}

Some other common operations, is how to combine two distinct graphs. Two common,
and especially relevant for the modular decomposition further down, is the
disjoint union and graph join. The disjoint union is the most simple way to
combine graphs, and just forms a new graph that just contains it's components
and nothing more. 
The graph join is similar, in that it produces a new graph with all of it's
subcomponents parts, edges and vertices, but also for every vertex in the one
component adds a new edge to the other component.

\begin{definition}[Disjoint union]
    The disjoint union $\bigcup_i G_i$ for graphs $G_i = (V_i,E_i)$ where 
    $\bigcap V_i = \varnothing $ , is a new graph
    $G = \left( \bigcup V_i,\bigcup E_i \right)$.
\end{definition}

\begin{definition}[Graph join]
    The graph join $\nabla G_i$ for graphs $G_i = (V_i,E_i)$ where 
    $\bigcap_i V_i = \varnothing$, is the new graph $G = (\{\bigcup V_i,
    \bigcup E_i \cup \{(u,v) : u \in V_k, v \in V_j, k \neq j \}$
\end{definition}


Another property of interest in graphs, is whether or not a graph is connected. A
graph being connected means that one can connect every vertex in the graph by
only moving between vertices that are neighbours. Especially important in the
case of graph coloring is that disconnected graph are split into parts that can
be colored separately, and therefore graph coloring can be restricted to only
deal with graphs that are connected.

\begin{definition}[Path]
    A path $p$ in graph $G = (V,E)$ is a sequence of vertices $p = (v_1\cdots
    v_i)$, such that the next vertex is a neighbour to the previous, 
    that is $\forall i(0 < i \leq |p| \to v_i \in N_G(v_{i-1})$.
\end{definition}

\begin{definition}[Connected graph]
    A graph $G = (V,E)$ is connected, if there exists a path between any two
    vertices in the graph. We say that a graph is disconnected if this isn't the
    case.
\end{definition}

The central problem in this thesis, is the efficient coloring of a graph.
Coloring graph means that one assigns every vertex a color, an arbitrary value,
such that no vertices that are neighbours have the same color. A classic
example of this problem is when coloring a map and wants to avoid giving
neighbouring countries the same color.  Every country can be represented by a
vertex, and edges are added if two countries share a border.

\begin{definition}[Graph coloring]
    A graph coloring $Col$ for a graph $G = (V,E)$ is function from $V$ to $C$,
    where $C$ is a set of colors, such that no neighbours share the same color,
    that is $|\{(u,v) : (u,v) \in E,Col(u) = Col(v)\}| = 0$. We say that $Col$
    is a $k$ coloring if $k \leq |C|$.
\end{definition}

Finding a coloring for a graph is easy, one could for example use
\autoref{alg:greedy}. Finding an optimal coloring however, a coloring using the
fewest possible colors is NP-Hard (REFERENS). For this purpose, multiple
different heuristics, algorithms providing a proper coloring with as few colors
as possible but not necessarily optimal, have to be used.


\begin{definition}[Complete graph]
    A graph $K = (V,E)$ is complete if every vertice is $v \in V$ is adjecent to
    every other vertex, that is, $\forall v \in V,\forall u \in V(v \neq u \to v
    \in N_K(u))$. We also denote the graph $K_i$ with the complete graph that
    has $i$ vertices.
\end{definition}

\subsection{Graph modules and cographs}
\label{sec:GraphModules}


\begin{definition}[Cograph]
    The set of cographs $Co$, is a set containing $K_1$ that is closed under 
    graph join and disjoint union. A graph $G$ is a cograph if $G \in Co$.
\end{definition}


\begin{definition}[Graph module]
    Let $G = (V,E)$ be an arbitrary graph. A non-empty vertex set $X \subset V$
    is a module of $G$ if, for every $y \in V \setminus X$,  either
    $N_G(y) \cap X = \emptyset$ or $X \subset N_G(y)$ is true. A module $M$ is
    strong if it does not overlap with any other module $M'$, i.e, if 
    $M \cap M' \in \{M,M',\emptyset \}$.
\end{definition}
  

Now we have sufficient terminology to describe the most central concept, the
modular decomposition. The modular decomposition is way to partition the
vertices of the graph into a tree structure, where the relation between
different modules, parts in the partitions, are known. Another way to look at
the modular decomposition, is that it's a cograph approximation of the original
graph, where parts that don't have a cograph structure are replaced with prime
modules.

\todo[noline]{Update definition}
\begin{definition}[Modular decomposition]
    For a graph $G = (V,E)$, let $PMax(G) = \{M_1,\cdots,M_k\}$ be a partition of the vertex set $V$ 
    into inclusion-maximal strong modules.
    
    The modular decomposition of the graph $G = (V,E)$ is a rooted, vertex labeled tree
    $(\widetilde{T},t)$, where each of its vertices is associated with a strong
    module $X \in PMax(G) \cup \{V\}$, and a label $t$ distinguishing  three cases:

    \begin{enumerate}
        \item Series: $G[X]$ is disconnected.
        \item Parallel: $\overline{G[X]}$ is disconnected.
        \item Prime: $G[X]$ and $\overline{G[X]}$ is disconnected.
    \end{enumerate}

    And where $V = X'$ when $X'$ is the strong component associated with the
    root node of the modular decomposition.
\end{definition}

Note, a label being series in modular decomposition tree with associated module
$X$ means that the induced subgraph $G[X]$ can be constructed through graph
union on the induced subgraphs of its children's associated modules, and it being
parallel means that $G[X]$ can be constructed through graph join on the
induced subgraphs of its childrens associated modules. (REFERENS)

This also means that modular decomposition without prime modules is a cograph, as 
it is Recursively constructed by graph join and graph union on $K_1$.

The modular decomposition of a graph is unique \cite{HCL}, which means that the
construction of the modular decomposition doesn't vary and need not be a part of
the heuristic.


\section{General coloring algorithm}

The algorithm used for coloring is algorithm 2 in \cite{HCL}. It provides a
optimal coloring given that the graph is a cograph. It does however not
provide a way to color the prime modules. This paper examines multiple different
ways these prime modules can be colored, split into 2 parts, a heuristic used,
and a coloring strategy. The heuristic is an ordinary coloring algorithm
providing an approximate optimal coloring, and the strategy is the way this
heuristic is applied. The different combinations of strategies and heuristic are
then compared against the baseline of applying the same heuristic on the whole
graph.

\begin{algorithm}[H]
  \caption{Modularly-minimal coloring a graph $G$ with MD tree $(T,t)$.}
  \label{alg:generic}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
    \REQUIRE Graph $G$ and MD tree $(\T,\t)$
    \STATE Initialize a coloring $\sigma$ s.t.\ all $v \in V(G)$
           have different colors
      \FORALL{$u\in V^{0}(T)$ \text{in post order}}
       \IF {$u$ is parallel} 
          \STATE $\mathcal{G} \leftarrow \{G(w)\colon w\in\child(u)\}$ 
          \STATE $G^* \leftarrow \argmax_{w\in\child(v)} |\chi(G(w))|$
          \STATE $S \leftarrow \sigma(V(G^*))$ 
          \FOR {$H\in\mathcal{G}\setminus \{G^*\}$} 
             \STATE randomly choose an injective map $\phi:\sigma(H)\to S$
             \FORALL {$x\in H$}
                \STATE $\sigma(x)\leftarrow \phi(\sigma(x))$  
             \ENDFOR
          \ENDFOR
       \ELSIF{$u$ is \emph{prime}} 
          \STATE Construct a modularly-minimal coloring of $G(u)$
              with colors contained in $\sigma(G(u))$
              and adjust $\sigma$ accordingly 
       \ENDIF
    \ENDFOR
  \end{algorithmic}
\end{algorithm}

Here, the last condition is of main interest, how to modularly-minimaly 
color a prime vertex.

\section{Heuristics}
\label{sec:Heuristics}

%ska man ta med sånt alla vet
A graph coloring heuristic is an algorithm for coloring a graph, that doesn't
necessarily give an optimal coloring, but uses various methods to approximate a
good coloring.


In this section, the different heuristics used to color the graph is described,
while \autoref{sec:strategies} describe how they are applied.
\subsection{Greedy}
The classic greedy algorithm. Greedy walks over all of the vertices in the graph
in an arbitrary order, and for every vertex assigns the first colored not shared
amongst it's neighbours. Being relatively simple, it also has fast runtime, with
a time complexity of $O(|V|+|E|)$ \cite{Constructive}

\begin{algorithm}[H]
  \caption{Greedy}
  \label{alg:greedy}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
    \REQUIRE Graph $G$
      \STATE $V' \leftarrow \text{List containing all $v \in V(G)$ in any order}$
      \STATE $C \leftarrow \text{List of all possible colors in any order}$
      \STATE $Col \leftarrow \text{Initial empty coloring}$
    \FORALL{$v \in V(G)$}
        \FORALL{$c \in C$}
            \IF {$c \neq Col(n) \text{for all $n \in N_G(v)$ } $}
                \STATE $Col \leftarrow \text{Updated coloring where $Col(v) =
                c$}$
                \BREAK
            \ENDIF
        \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}
\subsection{Dsatur}

Dsatur is an algorithm that is similar to Greedy, in that it walks through every
vertex and assigns it the first available color. The difference is mostly in
how this traversal is constructed. In greedy, this traversal is an arbitrary
order, but for Dsatur this traversal is constructed in a deterministic fashion,
by using the saturation degree.

\begin{definition}[Saturation degree]
    The saturation degree $sat(v)$ for a vertex $v \in V$ for a graph $G =
    (V,E)$ and a partial coloring $Col$ to the set of colors $C$, is the amount of unique colors among
    it's colored neighbours, that is $sat(v) = |\{c  : c = Col(v), v \in V \}|$.
\end{definition}

The vertex are colored so that the vertex with the highest saturation degree is
colored first, alternatively maximizing the degree. Compared to Greedy, this
algorithm does multiple passes over every vertex as every new coloring changes
the saturation degree for the remaining vertices. This means that the runtime
for the algorithm is higher, being
$O((|V|+|E|)\log{|V|})$ \cite{Constructive}.

DSatur being a well studied algorithm also means that it has some variations in 
the litterature, and this presentation is based on \cite{Constructive}.

\begin{algorithm}[H]
  \caption{Dsatur}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
      \REQUIRE Graph $G = (V,E)$
      \STATE $C \leftarrow \text{List of all possible colors in any order}$
      \STATE $Col \leftarrow \text{Initial empty coloring}$

      \FOR{$i$ between $0$ and $|V|$}

        \STATE $v \leftarrow$ uncolored vertex in $V$, such that $sat(v)$ is
        minimal. In case of ties, minimize $deg(v)$ for the subgraph of $G$
        induced by the uncolored vertices.
        \STATE $Col \leftarrow$ updated coloring where $Col(v)$ is the first
        available color in regards to $C$.
      \ENDFOR
  \end{algorithmic}
\end{algorithm}

\subsection{Recursive largest first}

Recursive largest first is more complicated than both Greedy and Dsatur, in both
execution and runtime. 

The idea behind Recursive largest first, is to create a partition of the
vertices of the graph, where the vertices in the different parts are all
non-adjacent to each other. This ensures that every partition can share the
same color. 

This construction is made by adding the vertex with the highest degree in the
induced subgraph of unpartitioned vertices to the current part that
isn't the neighbour of any vertex in the current part, and when no
such vertex exist, create a new empty part in the partition and continue. When
all of the vertices have been partitioned so is the coloring extracted by
assigning every part in the partition a unique color, and every vertex in that
part the same color.

This presentation of the algorithm is based on \cite{Constructive}.
\begin{algorithm}[H]
    \caption{Recursive largest first (RLF)}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
      \REQUIRE Graph $G = (V,E)$
      \STATE $\text{Partition} \leftarrow \{\}$
      \STATE $C \leftarrow \text{List of all possible colors in any order}$
      \STATE $M \leftarrow \{\}$
      \STATE $S \leftarrow V$
      \WHILE{$|S| > 0$}
        \STATE $v \leftarrow \text{the vertex maximizing $deg(v)$ for G[S]} $
        \STATE $M \leftarrow \{v\}$
        \WHILE{TRUE}
            \STATE Candidates $\leftarrow \{\}$
            \FORALL{$v' \in G[S]$}
                \IF{$v' \neq m \wedge v' \notin N_{G[S]}(m) \text{for all $m \in
                M$}$}
                    \STATE $\text{Candidates} \leftarrow \text{Candidates}
                    \cup \{v'\}$
                \ENDIF
            \ENDFOR
            \IF{$|\text{Candidates}| = 0$}
                \BREAK
            \ENDIF
            \STATE $n \leftarrow \text{the $n \in \text{Candidates}$ maximizing $deg(n)$ in $G[S]$}$ 
            \STATE $M \leftarrow M \cup \{n\}$
            \STATE $S \leftarrow S \setminus \{n\}$
        \ENDWHILE
        \STATE Partition $\leftarrow \text{Partition} \cup \{M\}$ 
      \ENDWHILE
      \STATE Assign consecutive colors from $C$ to the partitions in Partitions,
      and then color every vertex in that partition with that color.
  \end{algorithmic}
\end{algorithm}

\subsection{TabuCol}

TabuCol is a graph algorithm that unlike the previous algorithms, doesn't
construct a coloring in a constructive fashion, but instead tries to find a
coloring for a specific number target colors.

TabuCol first forms a random coloring, which most likely is not a proper
coloring, of the vertexes with colors from the allowed set, and then modifies
this coloring by looking at the vertexes that forms a clash, that is have
neighbours with the same colors. For these vertices, new coloring are evaluated
in how many clashes they would produce. Then vertex recoloring that has the
lowest new number of clashes, even if positive, is applied.

This can however introduce cycles, certain recolorings leading into each other
ad infinitum. To prevent this, the Tabu list is used. A Tabu list is a list 
of vertex-color pairs $(v,u)$. Whenever a new vertex recoloring is made, it is
added to the Tabu list. A new vertex recoloring is only considered if it's not a
part of the Tabu list. This tabu list have a set size, so that the first element
is removed when a new vertex-color pair is added.

Tabu moves are however allowed in some scenarios, specifically if applying that
coloring would create a better recoloring than any previously encountered for
the current number of clashes, which is commonly referred to as the aspiration.
An aspiration map is constructed, that initially has clashes set so that a
$Aspiration[ClashCount] = ClashCount-1$. For a given vertex-recoloring, if the
new number of clashes is lower than the aspiration for the current number of
clashes, so is that move allowed even if it's on the tabu list.

This process of picking a new vertex recoloring is repeated until a coloring
with zero clashes is produced, or a predetermined number of moves have been
made. As the algorithm only get's a valid coloring for a specific $k$, we also
must have a way to utilise this algorithm to get the lowest possible coloring.
Here the method used in \cite{Constructive} is used, that is, first a coloring is made
with Dsatur, and we call that number $k$. The then we try to color it with
TabuCol with that amount of colors minus one, and
subtract $k$ by one overtime we succeed, until we fail, at which point we say
that the current $k$ is the lowest we can go.

TabuCol has some subtle variations, and this particular definition is based on
the presentation in \cite{1990}. Alternatives are for example whether or not all
possible recolorings are consider, if only the first coloring with a lower clash
count is considered, and if one allows vertices that don't have any clashes to
be recolored.

\begin{algorithm}[H]
    \caption{TabuCol}
    \algsetup{linenodelimiter=}
    \begin{algorithmic}[1]
        \REQUIRE Graph $G = (V,E)$
        \REQUIRE Integer $k > 0$
        \REQUIRE Integer $MaxIt > 0$
        \REQUIRE Integer $MaxTabu > 0$
        \REQUIRE Integer $MaxRep > 0$
      
        \STATE $Asp \leftarrow \text{Map from every integer $0 < i < |V|$, such that $Asp[i] = i-1$}$
        \STATE $Col \leftarrow \text{random non-proper coloring with $k$ colors}$
        \STATE $CurIt \leftarrow 0$
        \STATE $CurrentClash = \textbf{Clashes}(Col)$
        \STATE $Tabu \leftarrow \text{Empty tabu list}$
        \WHILE{$CurrentClash < 0 $ and $CurIt < MaxIt$}
            \STATE $RepCount \leftarrow 0$
            \STATE $Reps \leftarrow \emptyset$
            \FORALL{$v \in V$}
                \IF{$RepCount > MaxRep$}
                    \BREAK
                \ENDIF
                \STATE $c \leftarrow \text{Random color $\neq Col(v)$ in $Col$}$
                \IF{$(v,c) \notin Tabu$ or $\textbf{Clashes} \text{ with $(v,c)$
                applied}\leq Asp[CurrentClash]$}
                    \STATE $Reps \leftarrow Reps \cup \{(v,c)\}$
                \ENDIF
                \STATE $RepCount \leftarrow RepCount + 1$
            \ENDFOR
            \STATE $(v',u') \leftarrow \text{where $(v',u') \in Reps$ and
            \textbf{Clashes} with $(v',u')$ applied is minimal }$
            \STATE $NewClash \leftarrow \textbf{Clashes}( (v',u')$
            \IF{$(v',u') \in Tabu$}
                \STATE $Asp[CurrentClash] = NewClash-1$
            \ENDIF
            \STATE $CurrentClash \leftarrow NewClash$
            \STATE Update $Tabu$ to contain $(v',u')$, and remove the oldest element if $|Tabu| > MaxTabu$
            \STATE Update $Col$ so that $Col(v') = u'$
            \STATE $CurIt \leftarrow CurIt + 1$
            \IF{$CurrentClash = 0$}
                \BREAK
            \ENDIF
        \ENDWHILE
    \end{algorithmic}
\end{algorithm}


\section{Strategies}
\label{sec:Strategies}
In the case where the whole graph doesn't contain any prime modules, coloring
with \autoref{alg:generic} is in linear time. It is when coloring prime modules
that we have to apply the heuristics, and these different methods are
described in this part.

\subsection{Whole graph}

In this baseline test, the whole graph is colored using the heuristic, not
utilizing the modular decomposition at all. This strategy is used as a baseline
to compare whether or not the other strategies improves the performance for the
graph.

\subsection{Whole prime coloring}

With this strategy, the prime vertex with the strong module $X$ of $G$, the
whole induced subgraph $G[X]$ is colored with the heuristic.

This method is the simplest combining strategy, but worth noting is that is
equivalent to coloring the whole graph using the heuristic in the case where the
root node is prime, and therefore only offers a possible improvement to existing
heuristics when the root in the modular decomposition isn't prime.

\subsection{Quotient recoloring}

This coloring, unlike the previous two, also attempts to colorize the prime
modules internally. Here, every prime module is colored just like in 'Whole
prime coloring', but only if it contains under a predetermined number of
vertices. Otherwise, all of it's children are colored first, then the quotient
graph for the children of the prime modules is constructed. This quotient graph
is then colored using the heuristic, and new every child moudle with the same
color in the quotient graph can now be recolored to use the same set of colors.

The quotient graph is graph describing whether or not vertex partitions of a
graph are adjecent or not, instead of individual vertices. Two vertex
partitions are adjecent in the quotient graph if there exists an edge between
any vertice, where one end is in the first partition, and the other end in the
other partition. A quotient graph where the partition is just the original
vertices, is therefore homomorphic to the original graph.

\begin{definition}[Quotient graph]
    The quotient graph $Q$ for a graph $G = (V,E)$ over partition 
    $P = \{P_1 \cdots P_i\}$  of the vertices $V$, is a graph 
    $Q = \{P, \{(P_i,P_j) : j\neq i, \exists v \in P_i,\exists u \in P_j( (u,v)
    \in E)   \}   $
\end{definition}

\todo[noline]{Add pseudocode}

\section{Data}
\label{sec:Data}

The test sets used are part graphs from the DIMACS benchmark set \cite{DIMACS}, 
and part graphs generated that aren't prime.

All of the graphs from the DIMACS benchmark sets are difficult to color graphs,
and also have modular decomposition where the root vertex is prime. As they are
commonly used benchmarks, they also provide known best current colorings for the
different graphs. However, the modular decomposition might provide a more
efficient way to color graphs where only some of the child nodes are prime. 

The algorithm for generating these graphs is described in \autoref{alg:RDCG}. First an
ordinary binary tree is randomly generated with a specified amount of leafs
vertexes, and then every label in this tree is given a label "series" or
"parallel".  This then describes a cograph, where the leafs are the K1 bases,
and a label of "series" means that the children are joined by disjoint union and a label
of "parallel" means that the children are joined by graph join. Then, from this
the corresponding graph can constructed. This forms one part of the test set.
From this graph, we also randomly add edges in predetermined number of modules
and with a predetermined size. This then forms a graph with a modular
decomposition which doesn't contain a prime module as the root, but still
contains prime modules.

This means that the training set are split into three parts, the DIMACS standard
benchmark, cographs, and graphs formed from these cographs with prime modules.


\subsection{Random graph generation}

\begin{algorithm}[H]
    \caption{Construct cograph}
    \algsetup{linenodelimiter=}
    \begin{algorithmic}[1]
        \REQUIRE Vertex labeled tree $T$
        \IF{$|V(T)| = 1$}
            \RETURN{$(V(T),\emptyset)$}
        \ENDIF
        \STATE $G \leftarrow \text{empty graph $(\emptyset,\emptyset)$}$
        \FORALL{$v \in N_T(root(T))$}
            \IF{Label of $root(T)$ is \textit{series}}
                \STATE $G \leftarrow \bigcup G, \text{\text{Construct cograph} applied
                on the subtree of $T$ with $v$ as root} $
            \ELSIF{Label of $root(T)$ is \textit{parallel}}
                \STATE $G \leftarrow \nabla G, \text{\text{Construct cograph} applied
                on the subtree of $T$ with $v$ as root}$
            \ENDIF
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Random disturbed cograph generation}
  \algsetup{linenodelimiter=}
  \label{alg:RDCG}
  \begin{algorithmic}[1]
      \REQUIRE Percent $p$ for serial, $0 \neq p \neq 1$.
      \REQUIRE Percent $pe$ for new  edge, $0 \neq pe \neq 1$.
      \REQUIRE Total amount of leafs $l$, $0 < l$.
      \REQUIRE Prime modules size $ps$
      \REQUIRE Prime modules count $pc$

      \STATE $bg \leftarrow \text{Random binary graph with leaf count equal to $l$}$
      \FORALL{$v \in bg$}
        \STATE Randomly assign a label  \textit{series}, or \textit{parallel} to $v$, so
        that the probability for \textit{series} is $p$.
      \ENDFOR

      \STATE $CG \leftarrow \text{\textbf{Construct graph} applied on $bg$}$

      \STATE $pm \leftarrow \text{All strong modules $M$ of $CG$ such that $|M| \geq ps$, ordered in increasing order by size}$
      \FOR{$i \cdots pc$}
        \STATE $cm \leftarrow \text{The module at index $i$ in $pm$}$
        \FORALL{vertex pairs $(u,v)$ where $u,v \in V(CG[cm])$}
            \STATE Modify $CG$ by adding edge $(u,v)$ with a chance of $pe$
        \ENDFOR
      \ENDFOR
      \RETURN{$CG$}
  \end{algorithmic}
\end{algorithm}

The cographs are disturbed in such a way that the expected amount of prime
modules and size of these modules can be tuned beforehand. By only adding edges
within a module, we can guarantee that only vertices in that module can be part
of a new prime module. By specifying how many modules we want and their size, we
can also construct modular decomposition with various percentage prime modules.


\section{Results and evaluation}
\label{sec:Result}
\todo[noline]{More everything, very unfinished}
Every graph in the training set is colored using all the different combinations
of heuristic and strategy, and the result can be found in (TABEL).

%\includegraphics[width=\textwidth]{Results.png}
%\includegraphics[width=\textwidth]{TestGGSave.png}
\subsection{DIMACS}
\input{DIMACSResult.tex}
\subsection{CoGraphs}
\input{CoGraphsResult.tex}
\subsection{Disturbed cographs}
\input{DisturbedCoGraphsResult.tex}


\subsection{Discussion}

Lorem ipsum

\printbibliography

\end{document}
