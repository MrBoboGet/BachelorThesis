\documentclass{amsart}
%\usepackage{amsmath} 
%\usepackage{amssymb}
%\usepackage{graphicx}
%\usepackage{pictex}
%\usepackage[noend]{algorithmic}
%\usepackage{algorithm}
%\renewcommand{\algorithmiccomment}[1]{\hfill$\rhd???$\textit{#1}}
%\usepackage{mathtools}
%\providecommand{\keywords}[1]{\textbf{\textit{Keywords: }} #1}
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}


% COPY PASTE

\usepackage{authblk}
%\usepackage[numbers,sort&compress]{natbib}
\usepackage[numbers, sort&compress]{natbib}

\usepackage[colorlinks]{hyperref}
\hypersetup{
	citecolor=blue,
   linkcolor=red,
}

\usepackage{amsmath, amssymb, amsfonts, amsfonts, amsthm,latexsym}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}
\renewcommand{\algorithmiccomment}[1]{\hfill$\rhd???$\textit{#1}}
\usepackage{graphics}
\usepackage{enumerate}
\usepackage[usenames]{color}
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}%[section]
\newtheorem{lemma}[theorem]{Lemma}%[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}[theorem]{Corollary}%[section]
\newtheorem{remark}[theorem]{Remark}%[section]
\newtheorem{problem}{Problem}[section]
\newtheorem{observ}{Observation}
\usepackage{url}
\RequirePackage{hyperref}
\DeclareMathOperator{\sgn}{sgn}

\DeclareSymbolFont{yhlargesymbols}{OMX}{yhex}{m}{n}
\DeclareMathAccent{\overarc}{\mathord}{yhlargesymbols}{"F3}

%%%%% SOME LOW LEVEL STUFF NEEDED FOR SPECIAL SYMBOLS 
\makeatletter
\def\moverlay{\mathpalette\mov@rlay}
\def\mov@rlay#1#2{\leavevmode\vtop{%
    \baselineskip\z@skip \lineskiplimit-\maxdimen
    \ialign{\hfil$\m@th#1##$\hfil\cr#2\crcr}}}
\newcommand{\charfusion}[3][\mathord]{
  #1{\ifx#1\mathop\vphantom{#2}\fi
    \mathpalette\mov@rlay{#2\cr#3}
  }
  \ifx#1\mathop\expandafter\displaylimits\fi}
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{\ifx#1\displaystyle.9\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}%
  }%
}
\makeatother
%%%%% END LOWLEVEL USER DEFINITION 
\newcommand{\bigjoin}{\bigop{\triangledown}}
\DeclareMathOperator{\join}{\triangledown}
\newcommand{\cupdot}{\charfusion[\mathbin]{\cup}{\cdot}}
\DeclareMathOperator{\bigcupdot}{\charfusion[\mathop]{\bigcup}{\cdot}}
\definecolor{jade}{rgb}{0.0, 0.66, 0.42}
\newcommand{\child}{\mathsf{child}}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\Pmax}{\mathrm{Pmax}}
\newcommand{\T}{\widetilde{T}}
\renewcommand{\t}{\widetilde{t}}

%\definecolor{darkorchid}{rgb}{0.6, 0.2, 0.8}

%\newcommand{\TODO}[1]{\begingroup\color{red}#1\endgroup}
\newcommand{\AX}[1]{\textnormal{#1}}
%%\newcommand{\NEW}[1]{\begingroup\color{blue}#1\endgroup}
%\newcommand{\dv}[1]{\begingroup\color{jade}#1\endgroup}
%\newcommand{\OLD}[1]{\begingroup\small	\color{green}#1\endgroup}
%\newcommand{\PFS}[1]{\begingroup\color{blue}#1\endgroup}
%\newcommand{\mhr}[1]{\begingroup\color{darkorchid}#1\endgroup}
%\newcommand{\mh}[1]{\begingroup\color{magenta}#1\endgroup}
%\newcommand{\mg}[1]{\begingroup\color{cyan}#1\endgroup}

%%\journal{European Journal of Combinatorics} 

\providecommand{\keywords}[1]{\textbf{\textit{Keywords: }} #1}

 % END COPY PASTE







\author{Emanuel Berggren}
\title{Graph coloring using modular decomposition}

\begin{document}
\maketitle

\section{Abstract}

\section{Introduction}

In this paper, we investigate a new heuristic using the modular decomposition of
a graph, and if it can be combined with other heuristics. 

The modular decomposition of a graph describes the structure of the graph, by
recursively splitting it into distinct modules. These modules contain some
vertexes from the graph, and can be further split into modules that partition
the top module. Every parent vertex also has a type, that determine how its submodules
combine to form their parent module.

Modular decomposition allows for coloring of graphs in linear time with optimal
chromatic number if all of the modules are vertexes are either  series or
parallel (REFERENS). However, if any of the vertexes are prime then optimal graph coloring 
is again NP-Hard, as prime vertexes cannot be recursively colored by this
method. The question examined here, is however if one can still utilize the
modular decomposition, with graph coloring heuristics for the prime colorings.
The modular decomposition might still color some parts of the graph optimally,
and the structure it provides might provide a hint for how to apply the
heuristics.

In section (PART) the basic terms are described.

In section (SECTION) the heuristics are described

In section (SECTION) the combination strategies are described, that is how are
these heuristics applied, and how is the structure of the modular decomposition
utilised.

In section (SECTION) the data and benchmarking methods are described. The data
used is both from DIMACS benchmarks (REFERENS), and custom generated data.

Finally, the results are presented in section (SECTION)

\section{Definitions}

\begin{definition}[Quotient graph]

\end{definition}

\begin{definition}[Cograph]

\end{definition}

\subsection{Modular decomposition}

\begin{definition}[Graph module]
    Let $G = (V,E)$ be an arbitrary graph. A non-empty vertex set $X \subset V$
    is a \textit{module} of $G$ if, for every $y \in V \setminus X$,  either
    $N(y) \cap X = \emptyset$ or $X \subset N(y)$ is true. A module $M$ is
    \textit{strong} if it does not overlap with any other module $M'$, i.e, if 
    $M \cap M' \in \{M,M',\emptyset \}$.
\end{definition}
   
%modular decomposition
\newpage
\begin{definition}[Modular decomposition]
    For a graph $G = (V,E)$, let $PMax(G) = \{M_1,\cdots,M_k\}$ be a partition of the vertex set $V$ 
    into inclusion-maximal strong modules.
    
    The modular decomposition of the graph $G = (V,E)$ is a directed, rooted, vertex labeled tree
    $(\widetilde{T},t)$, where each of its vertices is associated with a strong
    module $X \in PMax(G)$, and a label $t$ distinguishing  three cases:

    \begin{enumerate}
        \item Series: $G[X]$ is disconnected.
        \item Parallel: $\overline{G[X]}$ is disconnected.
        \item Prime: $G[X]$ and $\overline{G[X]}$ is disconnected.
    \end{enumerate}

    And where $V = X'$ when $X'$ is the strong component associated with the
    root node of the modular decomposition.
\end{definition}

Note, a label being series in modular decomposition tree with associated module
$X$ means that the induced subgraph $G[X]$ can be constructed through graph
union on the induced subgraphs of its childrens associated modules, and it being
parallell means that $G[X]$ can be constructed through graph join on the
induced subgraphs of its childrens associated modules.

The modular decomposition of a graph is unique (REFERENS), which means that the
construction of the modular decomposition doesn't vary and need not be a part of
the heuristic.


\begin{definition}[Partially color graphed]


\end{definition}

\section{General coloring algorithm}

The algorithm used for coloring is algorithm 2 in (REFERENS). It provides a
optimal coloring given that the graph is a cograph. It does however not
provide a way to color the prime modules. This paper examines multiple different
ways these prime modules can be colored, split into 2 parts, a heuristic used,
and a coloring strategy. The heuristic is an ordinary coloring algorithm
providing an approximate optimal coloring, and the strategy is the way this
heuristic is applied. The different combinations of strategies and heuristic are
then compared against the baseline of applying the same heuristic on the whole
graph.

\begin{algorithm}[t]
  \caption{Modularly-minimal coloring a graph $G$ with MD tree $(T,t)$.}
  \label{alg:modmin}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
    \REQUIRE Graph $G$ and MD tree $(\T,\t)$
    \STATE Initialize a coloring $\sigma$ s.t.\ all $v \in V(G)$
           have different colors
      \FORALL{$u\in V^{0}(T)$ \text{in post order}}
       \IF {$u$ is parallel} 
          \STATE $\mathcal{G} \leftarrow \{G(w)\colon w\in\child(u)\}$ 
          \STATE $G^* \leftarrow \argmax_{w\in\child(v)} |\chi(G(w))|$
          \STATE $S \leftarrow \sigma(V(G^*))$ 
          \FOR {$H\in\mathcal{G}\setminus \{G^*\}$} 
             \STATE randomly choose an injective map $\phi:\sigma(H)\to S$
             \FORALL {$x\in H$}
                \STATE $\sigma(x)\leftarrow \phi(\sigma(x))$  
             \ENDFOR
          \ENDFOR
       \ELSIF{$u$ is \emph{prime}} 
          \STATE Construct a modularly-minimal coloring of $G(u)$
              with colors contained in $\sigma(G(u))$
              and adjust $\sigma$ accordingly \label{alg:prime-color}
       \ENDIF
    \ENDFOR
  \end{algorithmic}
\end{algorithm}



\section{Heuristics}

%ska man ta med s√•nt alla vet
A graph coloring heuristic is an algorithm for coloring a graph, that doesn't
necessarily give an optimal coloring, but uses various methods to approximate a
good coloring. There are numerous graph coloring algorithms (REFERNENS) and is
one of the most well studies parts of graph theory (REFERENS). 

However, in order of be useful for the different STRATEGIES, a slightly
different problem is solved by these algorithms, and that is to colorize a
partially colored graph.

The algorithms used are therefore slightly modified versions of the 
Greedy (REFERENS), dsatur (REFERENS) and Recursive largest first (REFERENS). For
completeness, the algorithms are described fully here, with their modifications.



\subsection{greedy}


\subsection{dsatur}


\subsection{Recursive largets first}


\section{Strategies}

In the case where the whole graph doesn't contain any prime modules, coloring
can is easy (REFERENS), it is when coloring prime modules where we have to apply
the heuristics, and these different methods are described in this part.

\subsection{Whole graph}

In this baseline test, the whole graph is colored using the heuristic, not
utilizing the modular decomposition at all. This strategy is used as a baseline
to compare whether or not the other strategies improves the performance for the
graph.

\subsection{Whole prime coloring}

With this strategy, the prime vertex with the strong module $X$ of $G$, the
whole induced subgraph $G[X]$ is colored with the heuristic.

This method is the simplest combining strategy, but worth noting is that is
equivalent to coloring the whole graph using the heuristic in the case where the
root node is prime, and therefore only offers a possible improvement to existing
heuristics when the root in the modular decomposition isn't prime.

\subsection{Quotient recoloring}

With this method, all of the children for the prime vertex are first colored,
and then the quotient graph for the child modules are constructed. This quotient
graph is then colored. Then all of the child modules that have the same color
are recolored to use the same colors among the largest set of colors for the
modules.

%formal description


\subsection{Largest child first}

The largest child module is first colored with the same coloring algorithm, and
then the heuristic is applied on the partially colored induced subgraph 
$G[X]$.

%formal description

\subsection{Data}

The test sets used are part graphs from the DIMACS benchmark set (REFERENS), 
and part graphs generated that aren't prime.

All of the graphs from the DIMACS benchmark sets are difficult to color graphs,
and also have modular decomposition where the root vertex is prime. However, the
modular decomposition might provide a more efficient way to color graphs where
only some of the child nodes are prime. 

The algorithm for generating these graphs is described in figure 2. First an
ordinary binary tree is randomly generated with a specified amount of leafs
vertexes, and then every label in this tree is given a label 0 or 1.  This then
describes a cograph, where the leafs are the K1 bases, and a label of 1 means
that the children are joined by (GRAPH UNION) and a label of 0 means that the
children are joined by (GRAPH something). Then, from this the corresponding
graph can constructed. This forms one part of the test set. From this graph, we
also randomly add edges in predetermined number of modules and with a
predetermined size. This then forms a graph with a module decomposition which
doesn't contain a prime module as the root, but still contains prime modules.

This means that the training set are split into three parts, the DIMACS standard
benchmark, cographs, and graphs formed from these cographs with prime modules.

\subsection{Results and evaluation}

Every graph in the training set is colored using all the different combinations
of heuristic and strategy, and the result can be found in (TABEL).

\includegraphics[width=\textwidth]{Results.png}


\end{document}
