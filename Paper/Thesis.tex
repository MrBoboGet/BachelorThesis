\documentclass{amsart}
%\usepackage{amsmath} 
%\usepackage{amssymb}
%\usepackage{graphicx}
%\usepackage{pictex}
%\usepackage[noend]{algorithmic}
%\usepackage{algorithm}
%\renewcommand{\algorithmiccomment}[1]{\hfill$\rhd???$\textit{#1}}
%\usepackage{mathtools}
%\providecommand{\keywords}[1]{\textbf{\textit{Keywords: }} #1}
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}


% COPY PASTE

\usepackage{authblk}
%\usepackage[numbers,sort&compress]{natbib}
%\usepackage[numbers, sort&compress]{natbib}



\usepackage[colorlinks]{hyperref}
\hypersetup{
	citecolor=blue,
   linkcolor=red,
}

\usepackage{amsmath, amssymb, amsfonts, amsfonts, amsthm,latexsym}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}
\renewcommand{\algorithmiccomment}[1]{\hfill$\rhd???$\textit{#1}}
\usepackage{graphics}
\usepackage{enumerate}
\usepackage[usenames]{color}
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}%[section]
\newtheorem{lemma}[theorem]{Lemma}%[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}[theorem]{Corollary}%[section]
\newtheorem{remark}[theorem]{Remark}%[section]
\newtheorem{problem}{Problem}[section]
\newtheorem{observ}{Observation}
\usepackage{url}
\RequirePackage{hyperref}
\DeclareMathOperator{\sgn}{sgn}

\DeclareSymbolFont{yhlargesymbols}{OMX}{yhex}{m}{n}
\DeclareMathAccent{\overarc}{\mathord}{yhlargesymbols}{"F3}

%%%%% SOME LOW LEVEL STUFF NEEDED FOR SPECIAL SYMBOLS 
\makeatletter
\def\moverlay{\mathpalette\mov@rlay}
\def\mov@rlay#1#2{\leavevmode\vtop{%
    \baselineskip\z@skip \lineskiplimit-\maxdimen
    \ialign{\hfil$\m@th#1##$\hfil\cr#2\crcr}}}
\newcommand{\charfusion}[3][\mathord]{
  #1{\ifx#1\mathop\vphantom{#2}\fi
    \mathpalette\mov@rlay{#2\cr#3}
  }
  \ifx#1\mathop\expandafter\displaylimits\fi}
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{\ifx#1\displaystyle.9\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}%
  }%
}
\makeatother
%%%%% END LOWLEVEL USER DEFINITION 
\newcommand{\bigjoin}{\bigop{\triangledown}}
\DeclareMathOperator{\join}{\triangledown}
\newcommand{\cupdot}{\charfusion[\mathbin]{\cup}{\cdot}}
\DeclareMathOperator{\bigcupdot}{\charfusion[\mathop]{\bigcup}{\cdot}}
\definecolor{jade}{rgb}{0.0, 0.66, 0.42}
\newcommand{\child}{\mathsf{child}}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\Pmax}{\mathrm{Pmax}}
\newcommand{\T}{\widetilde{T}}
\renewcommand{\t}{\widetilde{t}}

%\definecolor{darkorchid}{rgb}{0.6, 0.2, 0.8}

%\newcommand{\TODO}[1]{\begingroup\color{red}#1\endgroup}
\newcommand{\AX}[1]{\textnormal{#1}}
%%\newcommand{\NEW}[1]{\begingroup\color{blue}#1\endgroup}
%\newcommand{\dv}[1]{\begingroup\color{jade}#1\endgroup}
%\newcommand{\OLD}[1]{\begingroup\small	\color{green}#1\endgroup}
%\newcommand{\PFS}[1]{\begingroup\color{blue}#1\endgroup}
%\newcommand{\mhr}[1]{\begingroup\color{darkorchid}#1\endgroup}
%\newcommand{\mh}[1]{\begingroup\color{magenta}#1\endgroup}
%\newcommand{\mg}[1]{\begingroup\color{cyan}#1\endgroup}

%%\journal{European Journal of Combinatorics} 

\providecommand{\keywords}[1]{\textbf{\textit{Keywords: }} #1}

 % END COPY PASTE


\usepackage[backend=bibtex]{biblatex}
\usepackage{todonotes}
\addbibresource{References.bib}


\newcommand{\algorithmicbreak}{\textbf{break}}
\newcommand{\BREAK}{\STATE \algorithmicbreak}
\newcommand{\algorithmautorefname}{Algorithm}
\author{Emanuel Berggren}
\title{Graph coloring using modular decomposition}

\begin{document}
\maketitle

\section{Abstract}

Lorem ipsum

\section{Introduction}

In this paper, we investigate a new heuristic using the modular decomposition of
a graph, and if it can be combined with other heuristics. 

The modular decomposition of a graph describes the structure of the graph, by
recursively splitting it into distinct modules. These modules contain some
vertexes from the graph, and can be further split into modules that partition
the top module. Every parent vertex also has a type, that determine how its submodules
combine to form their parent module.

Modular decomposition allows for coloring of graphs in linear time with optimal
chromatic number if all of the modules are vertexes are either  series or
parallel \cite{HCL}. However, if any of the vertexes are prime then optimal graph coloring 
is again NP-Hard, as prime vertexes cannot be recursively colored by this
method. The question examined here, if one can still utilize the
modular decomposition, with graph coloring heuristics for the prime modules.
The modular decomposition might still color some parts of the graph optimally,
and the structure it provides might provide a hint for how to apply the
heuristics on the prime parts, improving performance for other heuristics.

%kanske rätt onödigt?
In \autoref{sec:Definitions} all of the required terminology and definitions is
provided, and is split into two parts, \autoref{sec:GraphBasics} has definitions that might be
familiar to most people that have worked with graphs, and
\autoref{sec:GraphModules} provide the definitions that are more specific to
this paper.

In \autoref{sec:Heuristics} the heuristics used are described.

In \autoref{sec:Strategies} the combination strategies are described, that is how are
these heuristics applied, and how the structure of the modular decomposition is
utilised.

In \autoref{sec:Data} the test graphs and benchmarking methods are described. The data
used is both from standard DIMACS benchmarks \cite{DIMACS}, and custom generated data.

Finally, the results are presented in \autoref{sec:Result}.

\section{Definitions}
\label{sec:Definitions}

\subsection{Graph basics}
\label{sec:GraphBasics}

\begin{definition}[Graph]
    A graph $G = (V,E)$ is a tuple, where $V$ is the set of vertices, and $E$ is
    a set of pairs of vertices, the edges, such that for all $(v,u) \in E$,
    $v \in V$ and $u \in V$.
\end{definition}
\begin{definition}[Neighbour]
    For a graph $G = (V,E)$, we say that $v \in V$ is adjecent to 
    $u \in V$ if $(v,u) \in E$ or $(u,v) \in E$. 

    The neighbourhood $N_G(v)$ for a vertex $v \in V$ in a graph $G = (V,E)$,
    is the set of vertices that are adjecent to $v$, that is 
    $N_G(v) = \{u : (u,v) \in E \vee (v,u) \in E\}$. If $u \in N_G(v)$, we also say
    that $u$ and $v$ are neighbours.
\end{definition}

\begin{definition}[Degree]
    The degree for a vertex $v \in V$ in a graph $G = (V,E)$, denoted by 
    $deg(v)$, is the number of neighbours for $v$ in $G$, that is 
    $deg(v) = |N_G(v)|$.

\end{definition}

In many cases, one is interested in some parts of the graph, and one of the
most common ways to subset a graph is through the induced subgraph. The induced
subgraph is the graph constructed from another graph, by only including vertices
and edges within those vertices. 

\begin{definition}[Induced subgraph]
    
    For a graph $G = (V,E)$, the induced subgraph $G[X]$ for $X \subset V$, is
    an a new graph $(\{v \in X\},\{(u,v) : (u,v) \in E, u \in V,v \in V\})$. That
    is, a new graph only containing the vertices in $X$, and only edges between
    these vertices.

\end{definition}

Another common operation, is the graph complement. The graph complement for a
is in some sense the inverse of the original graph, it contains the same
vertices as the original graph, but the vertices are adjecent only of they where
not adjecent in the original graph.

\begin{definition}[Graph complement]
    The graph compliment $\widetilde{G}$ of a graph $G = (V,E)$ as a new graph 
    $(V,\{ (u,v) : u \in V,v \in V, (u,v) \notin E,(v,u) \notin E\})$.
\end{definition}

Some other common operations, is how to combine two distinct graphs. Two common,
and especially relevant for the modular decomposition further down, is the
disjoint union and graph join. The disjoint union is the most simple way to
combine graphs, and just forms a new graph that just contains it's components
and nothing more. 
The graph join is similar, in that it produces a new graph with all of it's
subcomponents parts, edges and vertices, but also for every vertex in the one
component adds a new edge to the other component.

\begin{definition}[Disjoint union]
    The disjoint union $\bigcup_i G_i$ for graphs $G_i = (V_i,E_i)$ where 
    $\bigcap_i V_i = \varnothing $ , is a new graph
    $G = \left( \bigcup_i V_i,\bigcup_i E_i \right)$.
\end{definition}

\begin{definition}[Graph join]
    The graph join $\nabla G_i$ for graphs $G_i = (V_i,E_i)$ where 
    $\bigcap_i V_i = \varnothing$, is the new graph $G = (\{\bigcup_i V_i,
    \bigcup_i E_i \cup \{(u,v) : u \in V_k, v \in V_j, k \neq j \}$
\end{definition}


\begin{definition}[Graph coloring]
    A graph coloring $Col$ for a graph $G = (V,E)$
    is function from $V$ to $C$, where $C$ is a set of colors. We say that 
    we have a $k$ coloring if $k \leq |C|$.
\end{definition}

Finding a coloring for a graph is easy, one could for example use
\autoref{alg:greedy}. Finding an optimal coloring hwoever, a coloring using the
fewest possible colors is NP-Hard (REFERENS). For this purpose, multiple
different heuristics, algorithms providing a proper coloring with as few colors
as possible but not necessarily optimal, have been created.

\begin{definition}[Quotient graph]

\end{definition}

\subsection{Graph modules and cographs}
\label{sec:GraphModules}

\begin{definition}[Cograph]
    The set of cographs $Co$, is a set containing $K_1$ that is closed under 
    graph join and disjoint union. A graph $G$ is a cograph of $G \in Co$.
\end{definition}


\begin{definition}[Graph module]
    Let $G = (V,E)$ be an arbitrary graph. A non-empty vertex set $X \subset V$
    is a module of $G$ if, for every $y \in V \setminus X$,  either
    $N_G(y) \cap X = \emptyset$ or $X \subset N_G(y)$ is true. A module $M$ is
    strong if it does not overlap with any other module $M'$, i.e, if 
    $M \cap M' \in \{M,M',\emptyset \}$.
\end{definition}
  

\todo[noline]{Update definition}
%modular decomposition
\begin{definition}[Modular decomposition]
    For a graph $G = (V,E)$, let $PMax(G) = \{M_1,\cdots,M_k\}$ be a partition of the vertex set $V$ 
    into inclusion-maximal strong modules.
    
    The modular decomposition of the graph $G = (V,E)$ is a directed, rooted, vertex labeled tree
    $(\widetilde{T},t)$, where each of its vertices is associated with a strong
    module $X \in PMax(G)$, and a label $t$ distinguishing  three cases:

    \begin{enumerate}
        \item Series: $G[X]$ is disconnected.
        \item Parallel: $\overline{G[X]}$ is disconnected.
        \item Prime: $G[X]$ and $\overline{G[X]}$ is disconnected.
    \end{enumerate}

    And where $V = X'$ when $X'$ is the strong component associated with the
    root node of the modular decomposition.
\end{definition}

Note, a label being series in modular decomposition tree with associated module
$X$ means that the induced subgraph $G[X]$ can be constructed through graph
union on the induced subgraphs of its children's associated modules, and it being
parallel means that $G[X]$ can be constructed through graph join on the
induced subgraphs of its childrens associated modules. (REFERENS)

This also means that modular decomposition without prime modules is a cograph, as 
it is Recursively constructed by graph join and graph union on $K_1$.

The modular decomposition of a graph is unique \cite{HCL}, which means that the
construction of the modular decomposition doesn't vary and need not be a part of
the heuristic.


\section{General coloring algorithm}

The algorithm used for coloring is algorithm 2 in \cite{HCL}. It provides a
optimal coloring given that the graph is a cograph. It does however not
provide a way to color the prime modules. This paper examines multiple different
ways these prime modules can be colored, split into 2 parts, a heuristic used,
and a coloring strategy. The heuristic is an ordinary coloring algorithm
providing an approximate optimal coloring, and the strategy is the way this
heuristic is applied. The different combinations of strategies and heuristic are
then compared against the baseline of applying the same heuristic on the whole
graph.

\begin{algorithm}[H]
  \caption{Modularly-minimal coloring a graph $G$ with MD tree $(T,t)$.}
  \label{alg:generic}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
    \REQUIRE Graph $G$ and MD tree $(\T,\t)$
    \STATE Initialize a coloring $\sigma$ s.t.\ all $v \in V(G)$
           have different colors
      \FORALL{$u\in V^{0}(T)$ \text{in post order}}
       \IF {$u$ is parallel} 
          \STATE $\mathcal{G} \leftarrow \{G(w)\colon w\in\child(u)\}$ 
          \STATE $G^* \leftarrow \argmax_{w\in\child(v)} |\chi(G(w))|$
          \STATE $S \leftarrow \sigma(V(G^*))$ 
          \FOR {$H\in\mathcal{G}\setminus \{G^*\}$} 
             \STATE randomly choose an injective map $\phi:\sigma(H)\to S$
             \FORALL {$x\in H$}
                \STATE $\sigma(x)\leftarrow \phi(\sigma(x))$  
             \ENDFOR
          \ENDFOR
       \ELSIF{$u$ is \emph{prime}} 
          \STATE Construct a modularly-minimal coloring of $G(u)$
              with colors contained in $\sigma(G(u))$
              and adjust $\sigma$ accordingly 
       \ENDIF
    \ENDFOR
  \end{algorithmic}
\end{algorithm}



\section{Heuristics}
\label{sec:Heuristics}

%ska man ta med sånt alla vet
A graph coloring heuristic is an algorithm for coloring a graph, that doesn't
necessarily give an optimal coloring, but uses various methods to approximate a
good coloring.

\subsection{Greedy}
The classic greedy algorithm, most likely the most simple heuristic. Greedy
walks over all of the vertices in the graph in an arbitrary order, and for every
vertex assigns the first colored not shared amongst it's neighbours. Being
relatively simple, it also has fast runtime, with a time complexity 
of $O(|V|+|E|)$ \cite{Constructive}

\begin{algorithm}[H]
  \caption{Greedy}
  \label{alg:greedy}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
    \REQUIRE Graph $G$
      \STATE $V' \leftarrow \textbf{List containing all $v \in V(G)$ in any order}$
      \STATE $C \leftarrow \textbf{List of all possible colors in any order}$
      \STATE $Col \leftarrow \textbf{Initial empty coloring}$
    \FORALL{$v \in V(G)$}
        \FORALL{$c \in C$}
            \IF {$c \neq Col(n) \textbf{for all $n \in N_G(v)$ } $}
                \STATE $Col \leftarrow \textbf{Updated coloring where $Col(v) =
                c$}$
                \BREAK
            \ENDIF
        \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}
\subsection{Dsatur}

Dsatur is an algorithm that is similar to Greedy, in that it walks through every
vertex and assigns it the first available color. The difference is mostly in
how this traversal is constructed. In greedy, this traversal is an arbitary
order, but for Dsatur this traversal is constructed in a deterministic fashion,
by using the saturation degree.

\begin{definition}[Saturation degree]
    The saturation degree $sat(v)$ for a vertex $v \in V$ for a graph $G =
    (V,E)$ and a partial coloring $Col$ to the set of colors $C$, is the amount of unique colors among
    it's colored neighbours, that is $sat(v) = |\{c  : c = Col(v), v \in V \}|$.
\end{definition}

The vertex are colored so that the vertex with the highest saturation degree is
colored first, alternatively maximizing the degree. Compared to Greedy, this
algorithm does multiple passes over every vertex as every new coloring changes
the saturation degree for the remainging vertices. This means that the runtime
fo  the algorithm as a consequence has a higher runtime of
$O((|V|+|E|)\log{|V|})$ \cite{Constructive}.

DSatur being an well studied algorithm also means that it has some variations in 
the litterature, and this presentation is based on \cite{Constructive}.

\begin{algorithm}[H]
  \caption{Dsatur}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
      \REQUIRE Graph $G = (V,E)$
      \STATE $C \leftarrow \textbf{List of all possible colors in any order}$
      \STATE $Col \leftarrow \textbf{Initial empty coloring}$

      \FOR{$i$ between $0$ and $|V|$}

        \STATE $v \leftarrow$ uncolored vertex in $V$, such that $sat(v)$ is
        minimal. In case of ties, minimize $deg(v)$ for the subgraph of $G$
        induced by the uncolored vertices.
        \STATE $Col \leftarrow$ updated coloring where $Col(v)$ is the first
        available color in regards to $C$.
      \ENDFOR
  \end{algorithmic}
\end{algorithm}

\subsection{Recursive largest first}

Recursive largest first is more complicated than both Greedy and Dsatur, in both
execution and runtime. 

The idea behind Recursive largest first, is to create a partition of the
vertices of the graph, where the vertices in the different parts are all
non-adjecent to each other. This ensures that every partition can share the
same color. 

This construction is made by adding the vertex with the highest degree in the
induced subgraph of unpartitioned vertices to the current module, and when no
such vertex exist, create a new empty part in the partition and continue. When
all of the vertices have been partitioned, the coloring is extracted by
assigning every partition a unique color, and every vertex in that part the same
color.

This presentation of the algorithm is based on \cite{Constructive}.
\begin{algorithm}[H]
    \caption{Recursive largest first (RLF)}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
      \REQUIRE Graph $G = (V,E)$
      \STATE $\textbf{Partition} \leftarrow \{\}$
      \STATE $C \leftarrow \textbf{List of all possible colors in any order}$
      \STATE $M \leftarrow \{\}$
      \STATE $S \leftarrow V$
      \WHILE{$|S| > 0$}
        \STATE $v \leftarrow \textbf{the vertex maximizing $deg(v)$ for G[S]} $
        \STATE $M \leftarrow \{v\}$
        \WHILE{TRUE}
            \STATE Candidates $\leftarrow \{\}$
            \FORALL{$v' \in G[S]$}
                \IF{$v' \neq m \wedge v' \notin N_{G[S]}(m) \textbf{for all $m \in
                M$}$}
                    \STATE $\textbf{Candidates} \leftarrow \textbf{Candidates}
                    \cup \{v'\}$
                \ENDIF
            \ENDFOR
            \IF{$|\textbf{Candidates}| = 0$}
                \BREAK
            \ENDIF
            \STATE $n \leftarrow \textbf{the $n \in \textbf{Candidates}$ maximizing $deg(n)$ in $G[S]$}$ 
            \STATE $M \leftarrow M \cup \{n\}$
            \STATE $S \leftarrow S \setminus \{n\}$
        \ENDWHILE
        \STATE Partition $\leftarrow \textbf{Partition} \cup \{M\}$ 
      \ENDWHILE
      \STATE Assign consecutive colors from $C$ to the partitions in Partitions,
      and then color every vertex in that partition with that color.
  \end{algorithmic}
\end{algorithm}

\subsection{TabuCol}

TabuCol is a graph algorithm that unlike the previous algorithms, doesn't
construct a coloring in a deterministic fashion, but instead tries to find a
coloring for a specific number target colors.

TabuCol first forms a random coloring of the vertexes with colors from the
allowed set, and then modifies this coloring by looking at the vertexes that
forms a clash, that is have neighbours with the same colors. For these vertices,
new coloring are evaluated in how many clashes they would produce. Then vertex
recoloring that has the lowest new number of clashes, even if positive, is
applied.

This can however introduce cycles, certain recolorings leading into each other
ad infinitum. To prevent this, the Tabu list is used. A tabu list is a list 
of vertex-color pairs $(v,u)$. Whenever a new vertex recoloring is made, it is
added to the tabu list. A new vertex recoloring is only considered if it's not a
part of the tabu list. This tabu list have a set size, so that the first element
is removed when a new vertex-color pair is added.

Tabu moves are however allowed in some scenarious, specifically if applying that
coloring would create a better recoloring than any previously encountered for
the current number of clashes, which is commonly refered to as the aspiration.
An aspiration map is constructed, that initially has clashes set so that a 
$Aspiration[ClashCount] = ClashCount-1$, that is, the coloring has to produce a
lower clash count. For a given vertex-recoloring, if the new number of clashes
is lower than the aspiration for the current number of clashes, so is that move
allowed even if it's on the tabu list.

This process of picking a new vertex recoloring is repeated until a coloring
with zero clashes is produced, or a predetermined number of moves have been
made. As the algorithm only get's a valid coloring for a specific $k$, we also
must have a way to utilise this algorithm to get the lowest possible coloring.
Here the method used in \cite{Constructive} is used, that is, first a coloring is made
with Dsatur, and the amount of colors used stubtracted by one is the original
$k$, and then we try to color it with TabuCol with that amount of colors, and
subtract $k$ by one evertime we suceed, until we fail, at which point we say
that the current $k$ is the lowest we can go.

TabuCol has some subtle variations, and this particular definition is based on
the presentation in \cite{1990}. Alternatives are for example whether or not all
possible recolorings are consider, if only the first coloring with a lower clash
count is considered, and if one allows vertices that don't have any clashes to
be recolored.

\begin{algorithm}[H]
    \caption{TabuCol}
    \algsetup{linenodelimiter=}
    \begin{algorithmic}[1]
        \REQUIRE Graph $G = (V,E)$
        \REQUIRE Integer $k > 0$
        \REQUIRE Integer $MaxIt > 0$
        \REQUIRE Integer $MaxTabu > 0$
        \REQUIRE Integer $MaxRep > 0$
      
        \STATE $Asp \leftarrow \text{Map from every integer $0 < i < |V|$, such that $Asp[i] = i-1$}$
        \STATE $Col \leftarrow \text{random non-proper coloring with $k$ colors}$
        \STATE $CurIt \leftarrow 0$
        \STATE $CurrentClash = \textbf{Clashes}(Col)$
        \STATE $Tabu \leftarrow \text{Empty tabu list}$
        \WHILE{$CurrentClash < 0 $ and $CurIt < MaxIt$}
            \STATE $RepCount \leftarrow 0$
            \STATE $Reps \leftarrow \emptyset$
            \FORALL{$v \in V$}
                \IF{$RepCount > MaxRep$}
                    \BREAK
                \ENDIF
                \STATE $c \leftarrow \text{Random color $\neq Col(v)$ in $Col$}$
                \IF{$(v,c) \notin Tabu$ or $\textbf{Clashes}$}
                    \STATE $Reps \leftarrow Reps \cup \{(v,c)\}$
                \ENDIF
                \STATE $RepCount \leftarrow RepCount + 1$
            \ENDFOR
            \STATE $(v',u') \leftarrow \text{where $(v',u') \in Reps$ and $\textbf{Clashes}( (v',u'))$ is minimal }$
            \STATE $NewClash \leftarrow \textbf{Clashes}( (v',u')$
            \IF{$(v',u') \in Tabu$}
                \STATE $Asp[CurrentClash] = NewClash$
            \ENDIF
            \STATE $CurrentClash \leftarrow NewClash$
            \STATE Update $Tabu$ to contain $(v',u')$, and remove the oldest element if $|Tabu| > MaxTabu$
            \STATE Update $Col$ so that $Col(v') = u'$
            \IF{$CurrentClash = 0$}
                \BREAK
            \ENDIF
        \ENDWHILE
    \end{algorithmic}
\end{algorithm}


\section{Strategies}
\label{sec:Strategies}
In the case where the whole graph doesn't contain any prime modules, coloring
with \autoref{alg:generic} is in linear time. It is when coloring prime modules
that we have to apply the heuristics, and these different methods are
described in this part.

\subsection{Whole graph}

In this baseline test, the whole graph is colored using the heuristic, not
utilizing the modular decomposition at all. This strategy is used as a baseline
to compare whether or not the other strategies improves the performance for the
graph.

\subsection{Whole prime coloring}

With this strategy, the prime vertex with the strong module $X$ of $G$, the
whole induced subgraph $G[X]$ is colored with the heuristic.

This method is the simplest combining strategy, but worth noting is that is
equivalent to coloring the whole graph using the heuristic in the case where the
root node is prime, and therefore only offers a possible improvement to existing
heuristics when the root in the modular decomposition isn't prime.

\subsection{Quotient recoloring}

This coloring, unlike the previous two, also attempts to colorize the prime
modules internally. Here, every prime module is colored just like in 'Whole
prime coloring', but only if it contains under a predetermined number of
vertices. Otherwise, all of it's children are colored first, then the quotient
graph for the children of the prime modules is constructed. This quotient graph
is then colored using the heuristic, and new every child moudle with the same
color in the quotient graph can now be recolored to use the same set of colors.

\todo[noline]{Add pseudocode}

\section{Data}
\label{sec:Data}

The test sets used are part graphs from the DIMACS benchmark set \cite{DIMACS}, 
and part graphs generated that aren't prime.

All of the graphs from the DIMACS benchmark sets are difficult to color graphs,
and also have modular decomposition where the root vertex is prime. As they are
commonly used benchmarks, they also provide known best current colorings for the
different graphs. However, the modular decomposition might provide a more
efficient way to color graphs where only some of the child nodes are prime. 

The algorithm for generating these graphs is described in figure 2. First an
ordinary binary tree is randomly generated with a specified amount of leafs
vertexes, and then every label in this tree is given a label "series" or
"parallel".  This then describes a cograph, where the leafs are the K1 bases,
and a label of "series" means that the children are joined by disjoint union and a label
of "parallel" means that the children are joined by graph join. Then, from this
the corresponding graph can constructed. This forms one part of the test set.
From this graph, we also randomly add edges in predetermined number of modules
and with a predetermined size. This then forms a graph with a modular
decomposition which doesn't contain a prime module as the root, but still
contains prime modules.

This means that the training set are split into three parts, the DIMACS standard
benchmark, cographs, and graphs formed from these cographs with prime modules.


\subsection{Random graph generation}

\begin{algorithm}[H]
    \caption{Construct cograph}
    \algsetup{linenodelimiter=}
    \begin{algorithmic}[1]
        \REQUIRE Vertex labeled tree $T$
        \IF{$|V(T)| = 1$}
            \RETURN{$(V(T),\emptyset)$}
        \ENDIF
        \STATE $G \leftarrow \textbf{empty graph $(\emptyset,\emptyset)$}$
        \FORALL{$v \in N_T(root(T))$}
            \IF{Label of $root(T)$ is \textit{series}}
                \STATE $G \leftarrow \bigcup G, \text{\textbf{Construct graph} applied
                on the subtree of $T$ with $v$ as root} $
            \ELSIF{Label of $root(T)$ is \textit{parallel}}
                \STATE $G \leftarrow \nabla G, \text{\textbf{Construct graph} applied
                on the subtree of $T$ with $v$ as root}$
            \ENDIF
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Random cograph generation}
  \algsetup{linenodelimiter=}
  \begin{algorithmic}[1]
      \REQUIRE Percent $p$ for serial, $0 \neq p \neq 1$.
      \REQUIRE Percent $pe$ for new  edge, $0 \neq pe \neq 1$.
      \REQUIRE Total amount of leafs $l$, $0 < l$.
      \REQUIRE Prime modules size $ps$
      \REQUIRE Prime modules count $pc$

      \STATE $bg \leftarrow \text{Random binary graph with leaf count equal to $l$}$
      \FORALL{$v \in bg$}
        \STATE Randomly assign a label  \textit{series}, or \textit{parallel} to $v$, so
        that the probability for \textit{series} is $p$.
      \ENDFOR

      \STATE $CG \leftarrow \text{\textbf{Construct graph} applied on $bg$}$

      \STATE $pm \leftarrow \text{All strong modules of $CG$ such that $|cg| \geq ps$, ordered in increasing order by size}$
      \FOR{$i \cdots pc$}
        \STATE $cm \leftarrow \text{The module at index $i$ in $pm$}$
        \FORALL{vertex pairs $(u,v)$ where $u,v \in V(CG[cm])$}
            \STATE Modify $CG$ by adding edge $(u,v)$ with a chance of $pe$
        \ENDFOR
      \ENDFOR
      \RETURN{$CG$}
  \end{algorithmic}
\end{algorithm}

The cographs are disturbed in such a way that the expected amount of prime
modules and size of these modules can be tuned beforehand. By only adding edges
within a module, we can guarantee that only vertices in that module can be part
of a new prime module. By specifying how many modules we want and their size, we
can also construct modular decomposition with various percentage prime modules.


\section{Results and evaluation}
\label{sec:Result}
Every graph in the training set is colored using all the different combinations
of heuristic and strategy, and the result can be found in (TABEL).

%\includegraphics[width=\textwidth]{Results.png}
%\includegraphics[width=\textwidth]{TestGGSave.png}
\include{DIMACSResult.tex}
\include{CoGraphsResult.tex}
\include{DisturbedCoGraphsResult.tex}


\subsection{Discussion}

Something that we can see from (TABLE), is that Greedy, RLF, DSatur all doesn't
perform better when applying the algorithm on the whole graph compared to all of
the prime modules locally. We can however see that TabuCol does on average
perform better when applying on the local submodules.

This might stem from the fact that Greedy,RLF,DSatur are all
(GREEDY-EQUIVALENT), and therefore colors cographs optimally, while this isn't
the case for TabuCol.

\printbibliography

\end{document}
